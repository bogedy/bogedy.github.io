(()=>{"use strict";var e,t,n,r,l={927:(e,t,n)=>{n.a(e,(async(e,t)=>{try{var n=32;const l=200,a=document.querySelector("canvas");if(!navigator.gpu)throw new Error("WebGPU not supported on this browser.");console.log("WebGPU is supported!");const i=await navigator.gpu.requestAdapter();if(!i)throw new Error("No appropriate GPUAdapter found.");const u=await i.requestDevice(),o=a.getContext("webgpu"),c=navigator.gpu.getPreferredCanvasFormat();let s,f,d,p,g,b,v,y,m,x,h,S;const P=new Float32Array([-.8,-.8,.8,-.8,.8,.8,-.8,-.8,.8,.8,-.8,.8]),w=u.createBuffer({label:"Cell vertices",size:P.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});u.queue.writeBuffer(w,0,P);const B={arrayStride:8,attributes:[{format:"float32x2",offset:0,shaderLocation:0}]};function U(){s=new Uint32Array(n*n),f=[u.createBuffer({label:"Cell State A",size:s.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),u.createBuffer({label:"Cell State B",size:s.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})];for(let e=0;e<s.length;e++)s[e]=Math.random()>.6?1:0;u.queue.writeBuffer(f[0],0,s);for(let e=0;e<s.length;e++)s[e]=e%2;u.queue.writeBuffer(f[1],0,s),x=u.createShaderModule({label:"Cell shader",code:"\n\n      @group(0) @binding(0) var<uniform> grid: vec2<f32>;\n      @group(0) @binding(1) var<storage> cellState: array<u32>;\n\n      struct VertexInput {\n        @location(0) pos: vec2<f32>,\n        @builtin(instance_index) instance: u32,\n      };\n\n      struct VertexOutput {\n        @builtin(position) pos: vec4<f32>,\n        @location(0) cell: vec2f,\n      };\n\n      @vertex\n      fn vertexMain(input: VertexInput) -> VertexOutput {\n        \n        let i = f32(input.instance);\n        let cell = vec2f(i % grid.x, floor(i / grid.x));\n        let state = f32(cellState[input.instance]);\n\n        let cellOffset = cell / grid * 2;\n        let gridPos = (input.pos*state + 1) / grid - 1 + cellOffset;\n\n        var output: VertexOutput;\n        output.pos = vec4f(gridPos, 0, 1);\n        output.cell = cell;\n        return output;\n      }\n\n      @fragment\n      fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n        let c = input.cell / grid;\n        return vec4f(1-c.x, c, .5);\n  }\n    "}),g=u.createBindGroupLayout({label:"Cell Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),y=u.createPipelineLayout({label:"Cell Pipeline Layout",bindGroupLayouts:[g]}),v=u.createRenderPipeline({label:"Cell pipeline",layout:y,vertex:{module:x,entryPoint:"vertexMain",buffers:[B]},fragment:{module:x,entryPoint:"fragmentMain",targets:[{format:c}]}}),d=new Float32Array([n,n]),p=u.createBuffer({label:"Grid Uniforms",size:d.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),u.queue.writeBuffer(p,0,d),b=[u.createBindGroup({label:"Cell renderer bind group A",layout:g,entries:[{binding:0,resource:{buffer:p}},{binding:1,resource:{buffer:f[0]}},{binding:2,resource:{buffer:f[1]}}]}),u.createBindGroup({label:"Cell renderer bind group B",layout:g,entries:[{binding:0,resource:{buffer:p}},{binding:1,resource:{buffer:f[1]}},{binding:2,resource:{buffer:f[0]}}]})],o.configure({device:u,format:c}),S=8,h=u.createShaderModule({label:"Game of Life simulation shader",code:`\n      @group(0) @binding(0) var<uniform> grid: vec2f;\n      @group(0) @binding(1) var<storage> cellStateIn: array<u32>;\n      @group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;\n\n      fn cell_index(cell: vec2u) -> u32 {\n        return (cell.y % u32(grid.y)) * u32(grid.x) + (cell.x % u32(grid.x));\n      }\n\n      fn cellActive(x: u32, y: u32) -> u32 {\n        return cellStateIn[cell_index(vec2(x, y))];\n      }\n\n      @compute\n      @workgroup_size(${S}, ${S})\n      fn computeMain(@builtin(global_invocation_id) cell: vec3u) {\n\n        let activeNeighbors = cellActive(cell.x+1, cell.y+1) +\n                          cellActive(cell.x+1, cell.y) +\n                          cellActive(cell.x+1, cell.y-1) +\n                          cellActive(cell.x, cell.y-1) +\n                          cellActive(cell.x-1, cell.y-1) +\n                          cellActive(cell.x-1, cell.y) +\n                          cellActive(cell.x-1, cell.y+1) +\n                          cellActive(cell.x, cell.y+1);\n\n        let i = cell_index(cell.xy);\n        switch activeNeighbors {\n          case 2: { // Active cells with 2 neighbors stay active.\n            cellStateOut[i] = cellStateIn[i];\n          }\n          case 3: { // Cells with 3 neighbors become or stay active.\n            cellStateOut[i] = 1;\n          }\n          default: { // Cells with < 2 or > 3 neighbors become inactive.\n            cellStateOut[i] = 0;\n          }\n        }\n      }`}),m=u.createComputePipeline({label:"Simulation pipeline",layout:y,compute:{module:h,entryPoint:"computeMain"}})}U();let G=0;function C(){const e=u.createCommandEncoder(),t=e.beginComputePass();t.setPipeline(m),t.setBindGroup(0,b[G%2]);const r=Math.ceil(n/S);t.dispatchWorkgroups(r,r),t.end(),G++;const l=e.beginRenderPass({colorAttachments:[{view:o.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:.4,b:.4,a:1},storeOp:"store"}]});l.setPipeline(v),l.setVertexBuffer(0,w),l.setBindGroup(0,b[G%2]),l.draw(P.length/2,n*n),l.end();const a=e.finish();u.queue.submit([a])}var r=setInterval(C,l);const E=document.getElementById("speedSlider");document.getElementById("speedValue").textContent=E.value;const _=document.getElementById("sizeSlider");document.getElementById("sizeValue").textContent=_.value,parseInt(E.value,10),E.addEventListener("input",(function(e){const t=e.target,n=parseInt(t.value,10);document.getElementById("speedValue").textContent=n.toString(),r&&clearInterval(r),r=setInterval(C,1e3/n)})),_.addEventListener("input",(function(){document.getElementById("sizeValue").textContent=this.value})),document.getElementById("restartBtn").addEventListener("click",(()=>{G=0,n=parseInt(_.value),U()})),t()}catch(O){t(O)}}),1)}},a={};function i(e){var t=a[e];if(void 0!==t)return t.exports;var n=a[e]={exports:{}};return l[e](n,n.exports,i),n.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",n="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",r=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},i.a=(l,a,i)=>{var u;i&&((u=[]).d=-1);var o,c,s,f=new Set,d=l.exports,p=new Promise(((e,t)=>{s=t,c=e}));p[t]=d,p[e]=e=>(u&&e(u),f.forEach(e),p.catch((e=>{}))),l.exports=p,a((l=>{var a;o=(l=>l.map((l=>{if(null!==l&&"object"==typeof l){if(l[e])return l;if(l.then){var a=[];a.d=0,l.then((e=>{i[t]=e,r(a)}),(e=>{i[n]=e,r(a)}));var i={};return i[e]=e=>e(a),i}}var u={};return u[e]=e=>{},u[t]=l,u})))(l);var i=()=>o.map((e=>{if(e[n])throw e[n];return e[t]})),c=new Promise((t=>{(a=()=>t(i)).r=0;var n=e=>e!==u&&!f.has(e)&&(f.add(e),e&&!e.d&&(a.r++,e.push(a)));o.map((t=>t[e](n)))}));return a.r?c:i()}),(e=>(e?s(p[n]=e):c(d),r(u)))),u&&u.d<0&&(u.d=0)},i(927)})();
//# sourceMappingURL=main.js.map